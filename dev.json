[
  {
    "id": 130,
    "title": "从零构建一个插件系统（六）低代码场景的插件构建思考",
    "content": "不知不觉，插件系统构建之旅来到了最终章。前面几篇我们从核心概念聊起，探讨了串行、并发、缓存等机制，还学习了 `Koa、Redux、Vue 3` 在各自领域中插件系统的实现。现在，让我们从低代码平台这个复杂的应用场景出发，完整阐述如何构建一个强大的插件系统。\n\n我在 2024 年的主要工作，就是深度参与一个基于 Vue 3 的低代码平台开发。这个平台功能丰富，简单概括如下：\n\n1.  多页面管理：类似于 Vue Router，支持多个路由页面。\n2.  组件拖拽与嵌套：多个组件可以相互嵌套，组合成一个更复杂的新组件。\n3.  协议驱动的属性配置：每个组件基于不同的协议，展示对应的属性配置面板。\n4.  事件与联动：通过配置事件，让组件能够影响自身和其他组件的状态。\n5.  全局历史与撤销重做：可以对大部分操作进行撤销与重做。\n6.  画布辅助工具：支持缩放、拖拽、标尺等功能。\n7.  预览与构建：可以快速预览和构建一个完整的工程。\n\n面对这样一个平台，如果用“面向过程”一把梭，后果可想而知。这恰恰是我们需要使用插件思想来去重新架构的地方。此外，我们要做的不是写一个简单的插件系统，而是为这个平台构建一个健壮、可扩展的“操作系统”。这篇文章，便是对之前工作的回顾与总结。\n\n> 推荐配合 [漫谈 AI + 低代码前景](https://juejin.cn/post/7530836683555258419) 一起阅读。这是我对未来低代码平台的一个展望，以及对 AI 的一些理解。\n\n## 顶层架构\n\n在深入细节之前，我们必须先确立整个系统的架构基石。面对如此复杂的、可撤销的、需要同步的状态变更，基于“命令模式”的架构是绝佳的选择。\n\n顶层架构包含三大核心：\n\n### 全局状态树\n\n一个由 Pinia 或 Vue `reactive` API 管理的、全局唯一的响应式对象，它定义了应用的“一切”。\n\n它看起来可能是这样的：\n\n```json\n{\n  \"project\": {\n    // 当前打开的项目，描述文档内容，需要持久化\n    \"id\": \"proj-123\",\n    \"name\": \"我的应用\",\n    \"pages\": {\n      \"page-main\": {\n        /* 首页的状态，包含组件树等 */\n      },\n      \"page-detail\": {\n        /* 详情页的状态 */\n      }\n    },\n    \"apis\": {\n      \"fetchUserList\": {\n        \"name\": \"fetchUserList\",\n        \"url\": \"https://api.example.com/users\",\n        \"method\": \"GET\",\n        \"description\": \"获取用户列表\"\n      }\n    }\n  },\n  \"session\": {\n    // 当前会话状态，描述用户交互，非持久化\n    \"currentPageId\": \"page-main\",\n    \"selectedComponentIds\": [\"comp-xyz\"],\n    \"canvas\": { \"zoom\": 1, \"pan\": { \"x\": 0, \"y\": 0 } }\n  },\n  \"history\": {\n    // 全局历史记录\n    \"undoStack\": [\n      /* Command 对象列表 */\n    ],\n    \"redoStack\": [\n      /* Command 对象列表 */\n    ]\n  }\n}\n```\n\n### 命令 (Command)\n\n任何对平台**内容**（如页面、组件、API 配置）有影响、需要被记录和撤销的修改，都必须被封装成一个“命令”对象。它是状态变更的原子单元。\n\n```ts\n/**\n * 定义所有命令都必须遵守的接口契约。\n */\ninterface Command {\n  execute(): void; // 正向执行\n  undo(): void; // 反向执行\n}\n\n/**\n * 一个具体的命令实现：添加组件。\n * 它封装了“添加一个组件”这个操作的所有信息和逻辑。\n */\nclass AddComponentCommand implements Command {\n  private pageId: string;\n  private componentData: any;\n\n  constructor(pageId: string, componentData: any) {\n    this.pageId = pageId;\n    this.componentData = componentData;\n  }\n\n  public execute(): void {\n    // 【核心】命令的 execute 方法直接修改全局状态树\n    // 假设 globalState 是全局可访问的状态树实例\n    globalState.project.pages[this.pageId]?.components.push(this.componentData);\n    console.log(`Command Executed: Added component ${this.componentData.id}`);\n  }\n\n  public undo(): void {\n    // 【核心】命令的 undo 方法以相反的方式修改全局状态树\n    const page = globalState.project.pages[this.pageId];\n    if (page) {\n      page.components = page.components.filter(\n        (c) => c.id !== this.componentData.id\n      );\n      console.log(`Command Undone: Removed component ${this.componentData.id}`);\n    }\n  }\n}\n```\n\n### 中心化命令执行器\n\n一个全局唯一的 `app.executeCommand()` 方法，它是所有状态变更的“咽喉要道”。\n\n```ts\n/**\n * 这是一个全局单例对象或类，提供了修改状态的唯一入口。\n */\nconst AppExecutor = {\n  /**\n   * 执行一个命令。这是所有状态变更的“咽喉要道”。\n   * @param command - 一个实现了 Command 接口的实例。\n   */\n  executeCommand(command: Command): void {\n    console.log(\"--- Executor: Receiving a new command ---\");\n\n    // 1. 调用命令的正向执行方法，真正地修改状态\n    command.execute();\n\n    // 2. 将命令推入撤销堆栈进行历史记录\n    globalState.history.undoStack.push(command);\n\n    // 3. 执行新命令后，必须清空重做堆栈\n    globalState.history.redoStack = [];\n\n    console.log(\n      `--- Executor: Command executed. Undo stack size: ${globalState.history.undoStack.length} ---`\n    );\n  },\n\n  /**\n   * 执行撤销操作。\n   */\n  undo(): void {\n    const command = globalState.history.undoStack.pop();\n    if (command) {\n      console.log(\"--- Executor: Undoing last command ---\");\n      command.undo();\n      globalState.history.redoStack.push(command);\n    }\n  },\n\n  /**\n   * 执行重做操作。\n   */\n  redo(): void {\n    const command = globalState.history.redoStack.pop();\n    if (command) {\n      console.log(\"--- Executor: Redoing last command ---\");\n      command.execute();\n      globalState.history.undoStack.push(command);\n    }\n  },\n};\n```\n\n这个架构可以用一张简单的图来表示：\n\n```text\n+------------------+      +--------------------+      +---------------------+\n|   各种插件        |----->|  app.executeCommand  |----->|     全局状态树       |\n| (工具, 属性面板) |      | (命令执行器)        |      |                      |\n+------------------+      +----------^---------+      +-----------^---------+\n       | 创建 Command             | 执行 Command               |           |\n       +--------------------------+                          | 响应式更新  |\n                                                           +-----------v---------+\n                                                           |       UI 视图        |\n                                                           | (画布, 面板等)      |\n                                                           +---------------------+\n```\n\n## 协议\n\n有了骨架，我们还需要定义构成这个世界的“物质”。在这个平台里，组件就是核心“物料”。为了让平台能识别和管理成百上千种不同的组件，我们必须建立一套“**协议**”。这是所有物料进入这个“世界”的通行证。\n\n我在这里选择使用 `Zod` 这个工具来定义协议。它不仅能描述数据结构，还能提供开箱即用的类型推断和运行时验证。\n\n一个标准的“按钮”组件，它的协议定义可能长这样：\n\n```typescript\n// protocols/button.protocol.ts\nimport { z } from \"zod\";\nimport { ButtonRenderer } from \"../renderers/Button.vue\"; // 引入 Vue 组件\nimport { ActionSchema } from \"./action.protocol\"; // 引入动作协议\n\n// 1. 定义组件的 Props Schema\nconst ButtonPropsSchema = z.object({\n  text: z.string().describe(\"按钮文字\").default(\"点击我\"),\n  type: z\n    .enum([\"primary\", \"default\", \"danger\"])\n    .describe(\"按钮类型\")\n    .default(\"default\"),\n});\n\n// 2. 定义组件支持的事件 Schema\nconst ButtonEventsSchema = z.object({\n  onClick: z.array(ActionSchema).describe(\"点击事件\").optional(),\n});\n\n// 3. 整合所有信息，形成完整的组件协议\nexport const ButtonProtocol = {\n  name: \"Button\",\n  label: \"按钮\",\n  props: ButtonPropsSchema,\n  events: ButtonEventsSchema,\n  renderer: ButtonRenderer, // 渲染器本身也是协议的一部分\n};\n```\n\n### 为什么协议如此重要？\n\n- 标准化：平台通过读取协议，就能知道如何创建它、如何为它生成属性面板、以及它能触发哪些事件。\n- 解耦：平台核心代码不依赖任何具体组件的实现，只依赖于这套抽象的协议。\n- 自动化：属性面板、代码生成器等工具，都可以基于协议自动工作。\n- 类型安全：`Zod` 让我们同时拥有了运行时的验证能力和开发时的 TypeScript 类型提示。\n\n## 插件化：内置工具的实现\n\n平台需要提供很多画布辅助工具，如选择、拖拽、缩放、标尺等。这些工具都应该被实现为“工具类插件”，并由一个“**工具管理器**”来统一调度。\n\n这里有一个关键的设计原则：**区分文档状态和会话状态**。\n\n在全局状态树中，`session` 部分是特殊的：\n\n```json\n\"session\": {\n  \"currentPageId\": \"page-main\",\n  \"selectedComponentIds\": [\"comp-xyz\"],\n  \"canvas\": { \"zoom\": 1, \"pan\": { \"x\": 0, \"y\": 0 } }\n}\n```\n\n它被设计为**非持久化**的，因为它描述的是当前用户与编辑器交互的临时状态，而不是文档内容本身。\n\n- 你把画布放大了 `200%`，这是你的个人视图偏好，不应该影响到你的同事看到的画布，也不属于文档内容。\n- 你选中了哪个组件，这是你下一步要编辑的目标，同样不属于文档内容。\n- 这些状态在刷新后可以丢失并重置为默认值。\n\n> 关键原则：\n> 对 `session` 状态的修改，**不应该**通过 `Command` 执行。因为它们是不需要被撤销、也不需要被同步给其他协作者的。\n\n基于此，工具插件的实现就非常清晰了：\n\n```typescript\n// plugins/ZoomToolPlugin.ts\nexport const ZoomToolPlugin = {\n  // 当插件被主应用加载时\n  setup(context) {\n    const canvasEl = context.getCanvasElement();\n    const sessionStore = context.getSessionStore();\n\n    const handleWheel = (event) => {\n      if (event.ctrlKey) {\n        event.preventDefault();\n        const newZoom = sessionStore.canvas.zoom - event.deltaY * 0.01;\n        // 直接修改 session state，不创建 Command，无需记录历史\n        sessionStore.canvas.zoom = Math.max(0.1, Math.min(newZoom, 5));\n      }\n    };\n\n    canvasEl.addEventListener(\"wheel\", handleWheel);\n\n    // 返回一个清理函数，在插件卸载时调用\n    return () => canvasEl.removeEventListener(\"wheel\", handleWheel);\n  },\n};\n```\n\n这种划分使得命令历史非常干净，只记录对文档内容的真正修改。\n\n## 组件拖拽\n\n组件拖拽的过程，可以看作是从一个界面事件到一条命令的“翻译”过程。下面我们来拆解用户的一个简单动作，是如何被我们的架构所处理的。\n\n流程：\n\n`用户拖拽物料 -> 画布监听到 drop 事件 -> 画布插件创建 AddComponentCommand -> app.executeCommand -> 状态更新 -> 界面响应式渲染`\n\n### 伪代码\n\n```typescript\n// plugins/CanvasPlugin.ts\nexport const CanvasPlugin = {\n  setup(context) {\n    const canvasEl = context.getCanvasElement();\n\n    const handleDrop = (event) => {\n      event.preventDefault();\n      const materialName = event.dataTransfer.getData(\"material/name\");\n      const position = { x: event.offsetX, y: event.offsetY };\n\n      // 1. 根据物料名称，从物料协议中获取默认数据\n      const protocol = context.getMaterialProtocol(materialName);\n      const defaultProps = zod.parse(protocol.props, {}); // 使用 Zod 解析出带默认值的 props\n\n      // 2. 创建一个描述“添加组件”这个意图的 Command\n      const command = new AddComponentCommand(\n        context.getSessionStore().currentPageId,\n        {\n          id: `comp-${Date.now()}`,\n          name: materialName,\n          props: { ...defaultProps, ...position },\n        }\n      );\n\n      // 3. 将命令提交给中心执行器，由它来改变世界\n      context.executeCommand(command);\n    };\n\n    canvasEl.addEventListener(\"drop\", handleDrop);\n    // ...还有 dragover 等事件的处理\n  },\n};\n```\n\n## 组件属性的配置\n\n组件属性的配置，是“协议驱动动态界面”的核心体现，也是“协议”强大之处的最佳证明。\n\n流程：\n\n`用户选中组件 -> Session 状态更新 -> 属性面板插件监听到变化 -> 读取组件协议 -> 动态生成界面 -> 用户修改界面 -> 属性面板插件创建 UpdatePropsCommand -> app.executeCommand`\n\n### 伪代码\n\n```vue\n<!-- components/PropertiesPanel.vue (属性面板插件的核心UI) -->\n<template>\n  <div v-if=\"selectedComponent\">\n    <h3>{{ protocol.label }} 属性</h3>\n    <!-- 动态遍历 Schema 并渲染对应的输入控件 -->\n    <div v-for=\"(schema, key) in protocol.props.shape\" :key=\"key\">\n      <label>{{ schema.description }}</label>\n      <component\n        :is=\"getControlForType(schema)\"\n        :modelValue=\"selectedComponent.props[key]\"\n        @update:modelValue=\"onPropChange(key, $event)\"\n      />\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { computed } from \"vue\";\nimport { useApp, UpdateComponentPropsCommand } from \"../core\";\n\nconst app = useApp();\nconst selectedComponent = computed(() => app.getSelectedComponent());\nconst protocol = computed(() =>\n  app.getProtocolForComponent(selectedComponent.value)\n);\n\nfunction onPropChange(key, newValue) {\n  // 创建一个更新属性的 Command\n  const command = new UpdateComponentPropsCommand(\n    {\n      /* ... target component info ... */\n    },\n    { [key]: newValue } // 只更新变化的属性，实现最小化更新\n  );\n  // 同样，交给中心执行器处理\n  app.executeCommand(command);\n}\n// ...\n</script>\n```\n\n## 接口配置\n\n一个应用如果不能与后端服务交互，那它只是一个静态的“模型”。为了赋予应用生命，我们必须能配置和调用 API。这同样遵循“协议驱动”的原则。\n\n平台内会有一个 API 管理面板，用户可以在其中定义所有需要用到的后端接口。这些定义，会作为项目内容的一部分，被储存在全局状态树的 `project.apis` 字段下。\n\n```typescript\n// protocols/api.protocol.ts\nimport { z } from \"zod\";\n\nexport const ApiProtocolSchema = z.object({\n  name: z.string().describe(\"API 唯一标识，如 fetchUserList\"),\n  url: z.string().url().describe(\"请求地址\"),\n  method: z.enum([\"GET\", \"POST\", \"PUT\", \"DELETE\"]).default(\"GET\"),\n  description: z.string().optional().describe(\"接口描述\"),\n  // 可以进一步定义 params, body, headers 的 schema\n});\n```\n\n使用起来则是有两种形式：\n\n1. 初始化请求数据给默认组件进行数据填充。\n2. 事件配置面板中，用户可以将按钮的“点击事件”与一个“调用 API”的动作绑定。\n\n### 设计哲学：拥抱 HTTP 状态码\n\n在接口规范上，我们建立了一条强制性原则：**所有后端接口必须直接使用 HTTP 状态码来表达成功或失败，严禁在响应体中包装一层业务状态码**（如 `{ code: 0, data: ..., msg: '...' }`）。\n\n- 成功：返回 `2xx` 状态码，响应体就是纯粹的数据 JSON。\n- 失败：返回 `4xx`（客户端错误）或 `5xx`（服务端错误）状态码，响应体可以携带错误的详细信息。\n\n为什么坚持这样做？\n\n1.  遵循 Web 标准：这是 API 设计的最佳实践，让 HTTP 协议本身回归其设计初衷。\n2.  简化前端逻辑：我们无需在每个请求后都写 `if (res.code === 0)` 这样的模板代码。`fetch` 或 `axios` 的 `catch` 块天然就能捕获所有非 `2xx` 的响应。\n3.  平台级错误处理：平台可以提供统一的 API 调用器。这个调用器能够自动处理错误，例如，当捕获到 `401` 时自动跳转到登录页，捕获到 `500` 时显示统一的错误提示。这极大减轻了低代码开发者的心智负担。\n\n这个看似简单的约束，实际上是整个平台稳定性和开发体验的基石之一。它使得数据交互的逻辑变得异常清晰和健壮。\n\n## 预览与构建\n\n当用户完成了页面设计、属性配置和事件联动后，就需要验证成果并最终发布。\n\n### 预览\n\n用户需要一个干净、独立的环境来真实地模拟终端用户的使用体验。\n\n设计思路：\n\n当用户点击“预览”按钮时，系统执行以下操作：\n\n1.  状态快照：将当前页面的完整 `project` 状态树序列化成一个 JSON。\n2.  新窗口加载：打开一个新的浏览器标签页，并加载一个专用的“预览运行器”页面。\n3.  状态注入：通过 `URL` 参数或 `localStorage` 将序列化后的状态 JSON 传递给这个新页面。\n4.  沙箱渲染：预览运行器启动一个迷你的 Vue 应用，它的唯一职责就是解析传入的状态 JSON，并使用动态渲染逻辑将其完整地渲染出来。\n\n这种方式创建了一个完美的沙箱环境。它与编辑器完全隔离，确保了预览的是应用的真实运行效果，不受任何编辑器插件或工具的影响。用户可以在这里自由点击、交互，验证所有数据请求和页面联动是否符合预期。\n\n### 最终构建\n\n预览通过后，就轮到正式的构建流程了。这需要一个更可靠、更专业的流程。\n\n设计思路：\n\n在云端服务器上运行一个独立的“构建器”程序。\n\n工作流程：\n\n1.  触发构建：编辑器将当前项目的完整 `project` 状态树序列化成一个 `project-schema.json` 文件并上传，然后触发一个云端构建任务。\n2.  代码生成：云端构建器读取这个 JSON。它会遍历每个页面，为每个页面生成一个真实的 `.vue` 文件，将组件树的渲染逻辑固化成模板代码。\n3.  联动翻译：对于组件的事件联动，构建器会将其翻译成 `@click` 等事件处理器。处理器内部的代码不再是执行命令，而是直接执行最终业务逻辑（例如，调用 API、修改另一个组件的某个 `ref` 值）。\n4.  标准打包：代码生成完毕后，构建器在服务器上调用 Vite 或 Webpack，对这些生成的源代码进行标准的打包、压缩和优化。\n5.  产出物：最终输出一套可以被部署到任何静态服务器的 HTML, JS, CSS 文件。\n\n这种方式将重量级的构建任务从用户的浏览器中移出，保证了构建过程的稳定和高效，是生产级低代码平台的标准做法。\n\n## 最后\n\n从一个简单的插件化想法出发，我们最终构建起了一个能够支撑复杂低代码平台的“操作系统”。这趟旅程的核心在于：\n\n- 协议是基石：标准化的组件协议，让所有“物料”都能被平台统一理解和管理。\n- 命令是灵魂：命令模式统一了所有状态变更的入口，轻松实现了撤销、同步和联动等复杂功能。\n- 插件是血肉：分而治之的插件体系，让每个功能模块（工具、属性面板、物料库、构建器）都能独立开发和演进。\n\n这套架构的初期投入看似复杂，但它为上层的“应用程序”（即我们开发的各种组件和功能插件）提供了一套稳定、强大且一致的 API。作为开发者，大部分时候，我们只需思考如何定义新的“协议”和实现新的命令，而无需陷入管理复杂状态和交互的泥潭。\n\n这就是整个插件系统构建之旅的终点——不是创造一个简单的工具，而是设计一个能够驾驭复杂性、拥抱未来变化的强大体系。希望这段从概念到实践的构建之旅，能为你提供一张可行的蓝图。\n",
    "createdAt": "2025-08-06T09:46:36Z",
    "updatedAt": "2025-08-06T09:46:36Z",
    "author": {
      "name": "bosens-China",
      "avatar": "https://avatars.githubusercontent.com/u/39508895?v=4"
    },
    "labels": [
      {
        "id": 1740577858,
        "name": "工具相关"
      }
    ],
    "reactions": 0,
    "comments": 0,
    "url": "https://github.com/bosens-China/blog/issues/130",
    "readingTime": 22,
    "excerpt": "不知不觉，插件系统构建之旅来到了最终章。前面几篇我们从核心概念聊起，探讨了串行、并发、缓存等机制，还学习了 Koa、Redux、Vue 3 在各自领域中插件系统的实现。现在，让我们从低代码平台这个复杂的应用场景出发，完整阐述如何构建一个强大的插件系统。 我在 2024 年的主要工作，就是深度参与一个...",
    "thumbnail": [],
    "column": null,
    "keywords": []
  },
  {
    "id": 129,
    "title": "从零构建一个插件系统（五）其他领域插件探讨",
    "content": "它山之石，可以攻玉，今天我们从插件系统的构建角度出发，探讨如何在特定的业务场景中实现插件。\n\n不过在开始之前，先提一嘴：插件的设计会因应用场景与具体业务需求的不同而有所差异，并没有所谓的“最优解”。你可能会看到一个简单的结构，但只要它能完美契合并满足需求，那么就是有效的设计。\n\n另外，尽管我们系列文章的主题是“插件”，但插件作为一个广泛的概念，其内涵远不止这一层。举个例子，Koa 的中间件是否可以算作插件呢？我认为是的，因为它符合了 **“保持核心精简，并提供机制，允许第三方代码介入核心处理流程，以扩展或修改其行为”** 的特征。\n\n本篇文章将从三个领域来探讨插件的设计与实现。\n\n> 插件的实现方式可能不会严格遵循源码结构，而是通过类似的代码示例来阐述插件系统是如何暴露机制、让外部代码介入的。\n\n## Vue 插件\n\n我们从最熟悉的前端框架 Vue 开始。Vue 插件最常见的使用场景包括：\n\n1. 通过 `app.component()` 和 `app.directive()` 注册全局组件或自定义指令。\n2. 通过 `app.provide()` 向整个应用提供可注入的资源。\n3. 向 `app.config.globalProperties` 中添加全局实例属性或方法。\n4. 功能库，可能涵盖上述几种功能（如 vue-router）。\n\n```javascript\nimport { createApp } from \"vue\";\n\nconst app = createApp({});\n\n// 插件是一个具有 install 方法的对象\nconst MyAwesomePlugin = {\n  install(app, options) {\n    // 1. 添加一个全局组件\n    app.component(\"MyButton\", MyButtonComponent);\n    // 2. 添加一个全局属性\n    app.config.globalProperties.$http = () => console.log(\"全局HTTP请求\");\n    // 3. 提供一个可被后代组件 inject 的值\n    app.provide(\"theme\", \"dark\");\n  },\n};\n\n// 使用插件\napp.use(MyAwesomePlugin, { someOption: true });\n```\n\n分析其设计思想：目标不是为应用编排一个流程，而是为已相当强大的 Vue 应用实例注入扩展能力，增强其全局特性。\n\n### 实现方式\n\n```javascript\n// a-mini-vue3.js\nclass MiniVueApp {\n  constructor() {\n    this.installedPlugins = new Set(); // 防止重复安装\n    this.components = {};\n    this.config = { globalProperties: {} };\n  }\n\n  use(plugin, ...options) {\n    if (this.installedPlugins.has(plugin)) return this;\n\n    // 直接调用插件的 install 方法，并将 app 实例和 options 传入\n    if (typeof plugin.install === \"function\") {\n      plugin.install(this, ...options);\n    } else if (typeof plugin === \"function\") {\n      // 也支持插件直接作为函数\n      plugin(this, ...options);\n    }\n\n    this.installedPlugins.add(plugin);\n    return this; // 支持链式调用\n  }\n\n  component(name, definition) {\n    this.components[name] = definition;\n  }\n\n  provide(key, value) {\n    // 简化版的 provide 实现\n  }\n}\n```\n\n核心逻辑：插件通过 `install` 方法接收 `this`（即 `app` 实例）作为第一个参数，提供了高度的灵活性，这是基于信任的设计。\n\n## Koa 中间件\n\nKoa 的中间件机制是插件化思想在 Web 服务器领域的经典体现。\n\n- 它的核心任务是：优雅地处理 HTTP 请求的完整流程，从“进来”到“出去”。\n\n该流程具有“进”与“回”两个阶段，Koa 的设计者为此设计了著名的“洋葱模型”。\n\n可以想象一下剥洋葱，一层层往里走，走到芯，再一层一层往外走。Koa 的中间件就是这样工作。\n\n```javascript\nconst Koa = require(\"koa\");\nconst app = new Koa();\n\n// 第一个中间件（最外层洋葱皮）\napp.use(async (ctx, next) => {\n  console.log(\">> 1. 请求进入...\");\n  const start = Date.now();\n\n  await next(); // 【关键】暂停当前中间件，把控制权交给下一个中间件\n\n  const ms = Date.now() - start;\n  console.log(`<< 4. 响应发出，耗时: ${ms}ms`);\n  ctx.set(\"X-Response-Time\", `${ms}ms`);\n});\n\n// 第二个中间件（内层洋葱皮）\napp.use(async (ctx, next) => {\n  console.log(\"  >> 2. 身份验证...\");\n  await next(); // 继续向内层中间件传递\n  console.log(\"  << 3. 内层已处理完毕...\");\n});\n\n// 核心业务逻辑（洋葱芯）\napp.use(async (ctx) => {\n  console.log(\"      -- 处理核心业务 --\");\n  ctx.body = `Hello, Koa`;\n});\n\napp.listen(3000);\n```\n\n设计思想：Koa 用 `await next()` 实现了优雅的流程控制，将请求处理过程分成了请求阶段和响应阶段。\n\n### 实现方式\n\n洋葱模型的核心思想是通过函数组合来实现中间件的嵌套调用，类似于递归。\n\n```javascript\n// a-mini-koa.js\nclass MiniKoa {\n  constructor() {\n    this.middlewares = [];\n  }\n\n  use(fn) {\n    this.middlewares.push(fn);\n  }\n\n  compose(middlewares) {\n    return function (context) {\n      function dispatch(i) {\n        const fn = middlewares[i];\n        if (!fn) return Promise.resolve();\n        try {\n          const next = dispatch.bind(null, i + 1);\n          return Promise.resolve(fn(context, next));\n        } catch (err) {\n          return Promise.reject(err);\n        }\n      }\n      return dispatch(0); // 从第一个中间件开始执行\n    };\n  }\n\n  handleRequest(context) {\n    const fn = this.compose(this.middlewares);\n    return fn(context);\n  }\n}\n```\n\n`compose` 通过递归和闭包，将所有中间件串联成一个执行链，从而实现了洋葱模型的效果。\n\n### 执行推演\n\n1. `use` 方法：每次调用 `app.use()`，Koa 会将中间件添加到 `middlewares` 数组中。\n2. `compose` `方法：compose` 会将这些中间件组合成一个大的执行链，形成一个类似洋葱模型的嵌套结构。每个中间件都会执行 `next()`，实现按顺序执行。\n3. 请求处理：当请求进入时，第一个中间件会执行，然后调用 `await next()`，控制权交给下一个中间件，直到核心业务逻辑处理完毕，返回响应。\n\n## Redux 中间件\n\nRedux 的核心非常简单，但其中间件机制则展现了函数式编程思想在插件化设计中的强大能力。\n\n- 它的核心任务是：在 `action` 被派发到 `reducer` 处理之前，提供一个可插拔、可组合的扩展点，用于处理副作用（例如异步请求、日志记录等）。\n\nRedux 中间件的签名看似复杂：`const myMiddleware = store => next => action => { ... }`，但这正是其强大之处。\n\n```javascript\n// thunk-middleware.js\nconst thunk = (store) => (next) => (action) => {\n  if (typeof action === \"function\") {\n    return action(store.dispatch, store.getState);\n  }\n  return next(action);\n};\n\n// 在创建 store 时应用中间件\nimport { createStore, applyMiddleware } from \"redux\";\nimport rootReducer from \"./reducers\";\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n```\n\n设计思想：Redux 中间件通过函数式编程链的方式，优雅地处理核心数据流的拦截和增强，专门用于副作用的管理。\n\n### 源码实现\n\n`applyMiddleware` 的实现，特别是 `compose` 函数和柯里化签名，复杂度相对较高。下面是一个简化版的实现过程。\n\n```javascript\n// a-mini-redux.js\n\n// applyMiddleware 的极简实现\nfunction applyMiddleware(...middlewares) {\n  return function enhancer(createStore) {\n    return function newCreateStore(...args) {\n      const store = createStore(...args);\n\n      let dispatch = () => {\n        throw new Error(\"不能在构造时调用 dispatch\");\n      };\n\n      const middlewareAPI = {\n        getState: store.getState,\n        dispatch: (...args) => dispatch(...args),\n      };\n\n      const chain = middlewares.map((middleware) => middleware(middlewareAPI));\n\n      const compose = (...funcs) =>\n        funcs.reduce(\n          (a, b) =>\n            (...args) =>\n              a(b(...args))\n        );\n\n      dispatch = compose(...chain)(store.dispatch);\n\n      return { ...store, dispatch };\n    };\n  };\n}\n```\n\nRedux 中间件的核心是通过 `compose` 将多个中间件串联起来，最终生成一个增强版的 `dispatch` 函数。\n\n### 执行推演\n\n1. `applyMiddleware：我们通过` `applyMiddleware(thunk)` 为 store 增强了中间件支持。\n2. 中间件链：每个中间件在执行时，都会执行 `next(action)`，即将 `action` 传递到下一个中间件。\n3. 异步处理：当 `dispatch` 派发的是一个函数时，`thunk` 中间件会拦截并执行该函数，传入 `dispatch` 和 `getState` 方法，完成异步请求，最终派发普通的 `action`。\n\n## 最后\n\n虽然这些插件设计实现形式各异，但它们的核心思想具有共通性：\n\n- Vue 3：通过 `install` 方法直接向中心实例注入全局能力。\n- Koa：使用洋葱模型优雅地控制有来有回的请求流程\n- Redux：通过函数式中间件链来拦截和增强单向数据流，专门处理副作用。\n",
    "createdAt": "2025-07-31T02:10:56Z",
    "updatedAt": "2025-07-31T02:10:56Z",
    "author": {
      "name": "bosens-China",
      "avatar": "https://avatars.githubusercontent.com/u/39508895?v=4"
    },
    "labels": [
      {
        "id": 1740577858,
        "name": "工具相关"
      }
    ],
    "reactions": 0,
    "comments": 0,
    "url": "https://github.com/bosens-China/blog/issues/129",
    "readingTime": 10,
    "excerpt": "它山之石，可以攻玉，今天我们从插件系统的构建角度出发，探讨如何在特定的业务场景中实现插件。 不过在开始之前，先提一嘴：插件的设计会因应用场景与具体业务需求的不同而有所差异，并没有所谓的“最优解”。你可能会看到一个简单的结构，但只要它能完美契合并满足需求，那么就是有效的设计。 另外，尽管我们系列文章的...",
    "thumbnail": [],
    "column": null,
    "keywords": []
  },
  {
    "id": 128,
    "title": "从零构建一个插件系统（四）插件的缓存",
    "content": "休息了几天，我们继续。今天来聊一聊插件的缓存。\n\n在一个系统中，合理的缓存策略是必不可少的。它像我们大脑的记忆，一方面可以提高执行效率，避免重复的、昂贵的计算；另一方面，在我们的场景里，它还能减少不必要的网络请求，在提升性能的同时，也避免了被上游 API 频繁骚扰。\n\n实现插件缓存，通常有两种思路：\n\n1. 插件内自行实现：每个插件自己负责读写缓存文件，管理自己的缓存逻辑。\n2. 系统级统一提供：由插件系统提供一套统一的、易于使用的缓存机制，供所有插件调用。\n\n方案一很灵活，但它把缓存管理的复杂性完全甩给了插件开发者。在我们的系列中，我们追求的是构建一个体验良好、易于使用的插件框架，所以，方案二——由系统统一支持缓存，无疑是更优的选择。\n\n## 系统级缓存的设计与集成\n\n我们先回顾一下上一章最终确定的插件形态：\n\n```ts\nexport class MyPlugin extends Plugin {\n  apply(hooks: PluginHooksRegister) {\n    hooks.onSomeHook(async (ctx) => {\n      // ... 插件逻辑 ...\n    });\n  }\n}\n```\n\n`apply` 方法是我们插件的入口，它接收一个 `hooks` 对象用来注册生命周期回调。这给了我们一个完美的扩展点：我们只需要在 `apply` 方法的参数中，再给它传递一个由系统创建好的 `cache` 实例，插件不就可以直接使用了吗？\n\n`plugin.apply(hooks, cache);`\n\n思路有了，我们来动手实现这个 `cache` 模块。\n\n## Cache 模块的实现\n\n这里我参考了经典库 [lowdb](https://github.com/typicode/lowdb) 的设计思想，它非常简洁且强大。同时，为了让每个插件的缓存互不干扰，我们会基于**插件的名称**来做命名空间的隔离。并且，利用 TypeScript 的泛型，我们可以为每个插件的缓存提供完美的类型支持。\n\n我们先看看理想中的使用方式：\n\n```ts\n// 插件中期望的用法\n// 1. 读取缓存\nif (cache.data) {\n  /* ... */\n}\n\n// 2. 写入/更新缓存\nawait cache.update((currentData) => {\n  // 返回全新的数据对象\n  return { ...currentData, newKey: \"newValue\" };\n});\n```\n\n下面是 `cache.ts` 的具体实现：\n\n```ts\n// cache.ts\nimport fs from \"fs/promises\";\nimport path from \"path\";\n\nexport class Cache<T> {\n  // 构造函数设为私有，强制开发者使用异步的 create 工厂方法\n  private constructor(private filePath: string, private dataCache: T) {}\n\n  /**\n   * 异步工厂方法：创建并初始化一个缓存实例。\n   * 它会优雅地处理文件不存在或内容非法的情况。\n   * @param filePath 缓存文件的绝对路径\n   * @param initialData 当缓存文件无法加载时使用的默认数据\n   */\n  static async create<T>(filePath: string, initialData: T): Promise<Cache<T>> {\n    try {\n      const content = await fs.readFile(filePath, \"utf-8\");\n      // 成功读取并解析，用文件内容初始化\n      return new Cache(filePath, JSON.parse(content));\n    } catch {\n      // 文件不存在或解析失败，使用初始数据\n      // 同时确保缓存目录存在，避免写入时出错\n      await fs.mkdir(path.dirname(filePath), { recursive: true });\n      return new Cache(filePath, initialData);\n    }\n  }\n\n  /**\n   * 获取当前缓存的数据快照。\n   */\n  get data(): T {\n    return this.dataCache;\n  }\n\n  /**\n   * 接收一个更新函数，用其返回值更新缓存，并异步地将结果写入文件。\n   * @param updater 一个接收当前数据并返回新数据的纯函数。\n   */\n  update(updater: (data: T) => T): Promise<void> {\n    this.dataCache = updater(this.dataCache);\n    // 格式化 JSON 输出，方便调试\n    return fs.writeFile(this.filePath, JSON.stringify(this.dataCache, null, 2));\n  }\n}\n```\n\n## 在插件系统中集成 Cache\n\n现在，我们在 `PluginSystem` 的 `collectHooks` 方法中，为每个插件创建并注入一个专属的 `Cache` 实例。\n\n```ts\n// core.ts (部分代码)\nexport class PluginSystem {\n  private cacheDir = path.resolve(process.cwd(), \".cache\");\n\n  private async collectHooks() {\n    for (const plugin of this.plugins) {\n      const register: PluginHooksRegister = {\n        /* ... */\n      };\n\n      // 使用插件的类名作为缓存文件的唯一标识，确保隔离\n      const cacheKey = plugin.constructor.name;\n      const cachePath = path.join(this.cacheDir, `${cacheKey}.json`);\n\n      // 注意：初始数据设为 null，让插件自己决定缓存的结构和初始状态\n      const cache = await Cache.create(cachePath, null);\n\n      // 将 cache 实例作为第二个参数传递给 apply 方法\n      plugin.apply(register, cache);\n    }\n  }\n}\n```\n\n同时，我们也需要更新一下 `Plugin` 的基类定义，让它可以接收泛型和 `cache` 参数。\n\n```ts\n// types.ts (部分代码)\nexport abstract class Plugin<TCache = unknown> {\n  // 允许插件定义自己的缓存类型\n  // ...\n  abstract apply(\n    hooks: PluginHooksRegister,\n    cache: Cache<TCache | null> // cache 是可选的，且初始数据可能为 null\n  ): void;\n}\n```\n\n## 插件的全新使用方式\n\n有了系统级的缓存支持，我们的 `FetchIssues` 插件现在可以变得非常智能。\n\n```ts\n// plugins/FetchIssues.ts\n\n// 1. 定义插件，并传入它的缓存数据类型\ninterface IssuesCache {\n  issues: Issue[];\n}\n\nexport class FetchIssues extends Plugin<IssuesCache> {\n  // 2. 在 apply 方法中接收 cache 实例\n  apply(hooks: PluginHooksRegister, cache: Cache<IssuesCache | null>) {\n    hooks.onLoad(async (ctx) => {\n      // 3. 优先从缓存读取\n      if (cache?.data?.issues) {\n        console.log(`[${this.name}] -> 命中缓存，从本地加载 issues...`);\n        cache.data.issues.forEach((issue) => ctx.emitIssue(issue));\n        return; // 命中缓存，直接结束\n      }\n\n      // 4. 缓存未命中，执行原始的、昂贵的拉取逻辑\n      console.log(`[${this.name}] -> 缓存未命中，开始从远程拉取 issues...`);\n      // ... (省略 sleep 和 fetch 逻辑)\n      const fetchedIssues = [\n        /* ... */\n      ];\n\n      fetchedIssues.forEach((issue) => ctx.emitIssue(issue));\n\n      // 5. 将新拉取的数据写入缓存，以便下次使用\n      await cache?.update(() => ({ issues: fetchedIssues }));\n\n      console.log(`[${this.name}] -> issues 拉取完成并已写入缓存。`);\n    });\n  }\n}\n```\n\n## `update` 的性能优化思考\n\n目前我们的 `update` 方法每次调用都会立即执行一次磁盘写入。如果在一个钩子中，某个插件非常频繁地调用 `update`，就可能造成大量的 I/O 操作。\n\n这里完全可以借鉴 Vue 响应式系统的思想：批量异步更新。我们可以维护一个写入队列（`writeQueue`）和一个“脏”标记（`isDirty`）。\n\n1.  当 `update` 被调用时，它只更新内存中的 `dataCache`，并将 `isDirty` 设为 `true`。\n2.  同时，如果当前没有正在等待的写入任务，就用 `process.nextTick` 或 `Promise.resolve().then()` 注册一个微任务。\n3.  在这个微任务中，才真正地执行 `fs.writeFile`，将内存中最新的数据一次性写入磁盘，并重置“脏”标记。\n\n这样，无论插件在一次事件循环中调用了多少次 `update`，最终都只会触发一次实际的磁盘写入。\n\n```ts\nimport fs from \"fs/promises\";\nimport path from \"path\";\n\nexport class Cache<T> {\n  private isDirty = false; // 是否有待写入的更新\n  private writeScheduled = false; // 是否已调度写入任务\n\n  private constructor(private filePath: string, private cache: T) {}\n\n  static async create<T>(filePath: string, initialData: T): Promise<Cache<T>> {\n    try {\n      const content = await fs.readFile(filePath, \"utf-8\");\n      return new Cache(filePath, JSON.parse(content));\n    } catch {\n      await fs.mkdir(path.dirname(filePath), { recursive: true });\n      return new Cache(filePath, initialData);\n    }\n  }\n\n  get data(): T {\n    return this.cache;\n  }\n\n  update(fn: (data: T) => T): void {\n    this.cache = fn(this.cache);\n    this.isDirty = true;\n    this.scheduleWrite();\n  }\n\n  private scheduleWrite() {\n    if (this.writeScheduled) return;\n    this.writeScheduled = true;\n\n    // 用微任务合并当前事件循环内的多次更新\n    Promise.resolve().then(() => this.flush());\n  }\n\n  async flush(): Promise<void> {\n    if (!this.isDirty) {\n      this.writeScheduled = false;\n      return;\n    }\n    this.isDirty = false;\n    this.writeScheduled = false;\n\n    await fs.writeFile(\n      this.filePath,\n      JSON.stringify(this.cache, null, 2),\n      \"utf-8\"\n    );\n  }\n}\n```\n\n## 最后\n\n这篇我们实现了一个简单但设计思想完备的系统级缓存机制。将复杂性（如文件 I/O、错误处理、性能优化）封装在框架内部，而为开发者提供一个极其简洁的 API，这正是优秀框架设计的核心。合理的缓存，能让我们的插件系统在二次运行时，速度得到质的飞跃。\n\n下一篇，我们将暂时跳出自己的实现，放眼业界，去探讨和借鉴其他领域的插件系统（如 Koa、Vue、VS Code）的设计思想，看看能从中吸收哪些宝贵的经验。\n",
    "createdAt": "2025-07-29T08:36:16Z",
    "updatedAt": "2025-07-29T08:36:25Z",
    "author": {
      "name": "bosens-China",
      "avatar": "https://avatars.githubusercontent.com/u/39508895?v=4"
    },
    "labels": [
      {
        "id": 1740577858,
        "name": "工具相关"
      }
    ],
    "reactions": 0,
    "comments": 0,
    "url": "https://github.com/bosens-China/blog/issues/128",
    "readingTime": 10,
    "excerpt": "休息了几天，我们继续。今天来聊一聊插件的缓存。 在一个系统中，合理的缓存策略是必不可少的。它像我们大脑的记忆，一方面可以提高执行效率，避免重复的、昂贵的计算；另一方面，在我们的场景里，它还能减少不必要的网络请求，在提升性能的同时，也避免了被上游 API 频繁骚扰。 实现插件缓存，通常有两种思路： 插...",
    "thumbnail": [],
    "column": null,
    "keywords": []
  },
  {
    "id": 127,
    "title": "AI 助手项目的得与失",
    "content": "分享一下我 5 月从事文旅 AI 助手的一些得与失，并探讨在对话场景下，怎样实现才更为合理。\n\n首先补充一下项目背景：该项目涉及景区、美食、停车场、酒店、天气等信息。要求是：当用户提问时，系统能够基于数据库的内容进行润色后回答，且回答的模板可能是固定的，类似下面这种\n\n<img width=\"778\" height=\"1406\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/f360a9e1-d493-44a3-88d7-4ff04c6d2258\" />\n\n不过，很快就遇到了第一个问题：如何切分数据。\n\n最初的实现思路是基于 Agent + RAG + Dify 的组合来搭建和管理，流程大致如下：\n\n<img width=\"1594\" height=\"1052\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/3f35e157-a0af-4ed2-8d9e-f2026e3e0415\" />\n\n## 如何切分\n\n数据库的字段大概是下面这种形式：\n\n```json\n{\n  \"name\": \"景点名称\",\n  \"type\": \"景点类型\",\n  \"address\": \"景点地址\",\n  \"description\": \"景点描述\",\n  \"price\": \"景点价格\",\n  \"time\": \"景点开放时间\",\n  \"ticket\": \"景点门票\",\n  \"phone\": \"景点联系电话\",\n  \"email\": \"景点联系邮箱\",\n  \"website\": \"景点官网\",\n  \"image\": \"景点图片\"\n}\n```\n\n对于这种结构化数据，如果直接进行切分，效果会比较差。当时查阅了很多文章，也做了一些调研，后来实践发现，将其直接转化为 Markdown 格式是比较合适的方案，然后在段落之间手动添加特殊的分隔符（例如 `---`）来标识切分点。\n\n但这还没完，很快发现一个新问题：“景点描述”字段内容过长，超出了向量模型处理的最大长度限制，这带来了很大的麻烦。当时想了两个方案：\n\n1. 调高重叠段落（overlap）的字符数。\n2. 将单条数据拆分成多个文件上传。\n\n但折腾了一番后，这两个方案都没能解决问题。究其原因，RAG 的本质是对段落信息进行检索。\n\n1. 由于原始文本太长，切分后的段落非常零散，导致关键信息无法被有效召回。\n2. 将数据库的每一行拆分成多个 MD 文件上传，但在实践中效果依然不佳，因为检索时系统会返回整个文件的内容，导致 Token 消耗量过大。\n\n所以，这是我的第一个感悟：对于传统的结构化数据，将其转化为 MD 格式用于关键词检索通常已经足够。但如果某些字段（如描述）内容过长，就需要考虑其他实现方式。站在今天的视角来看，我认为最佳做法依然是 RAG，但核心思路有所调整：**在向量索引中，不存储完整的“景点介绍”这类长文本，而是只存储其 ID。**\n\n这样，检索流程就变成了：先通过 RAG 检索到相关的 ID，再根据 ID 从数据库中查询详细的介绍信息，最后将信息拼接返回。\n\n此外，随着后续 MCP Server（Model Control Plane，可以理解为模型工具调用服务）的推出，许多数据库也可以结合 LLM 直接实现信息检索。\n\n> 需要注意配置 MCP 以及模型本身是否支持工具调用。\n\n所以，概括一下，对于结构化数据场景，可以从以下两个方面来实现信息检索：\n\n1.  基于 RAG（优化为 ID 检索 + 数据库查询）\n2.  基于 MCP Server（工具调用）\n\n### 天气\n\n天气查询这部分也值得单独思考。初始版本是基于“固定城市 + 专用天气接口”的方式来实现的，但这是否为最优解呢？我认为不是。\n\n后来到了 6 月，新版的 DeepSeek 推出了模型联网功能，这使得天气查询问题变得简单多了。模型可以直接从百度等网站上实时爬取信息，从而天然地支持了对任意城市的查询。\n\n此外，随着 MCP 生态的完善，许多天气相关的 API 也支持通过 MCP 进行调用，通常只需配置一个 Token 即可轻松实现。\n\n### Prompt\n\nPrompt 的编写也值得一提。市面上关于 Prompt 的文章和教程有很多，甚至还催生了“提示词工程师”这样的岗位。但对于一个流程清晰的项目而言，我认为遵循以下两个建议，就足以编写出可用的提示词：\n\n1.  **利用模型生成初版**：基于最新的模型（如 Gemini、ChatGPT），让它根据你的需求生成一份基础提示词。\n2.  **提供范例（Few-shot Learning）**：LLM 可以通过少量样本来学习回答的格式和范例。如有需要，还可以加入负面样本（例如，不希望看到的回复）或明确的禁止项（例如，禁止回答某些话题）来进一步规范输出。\n\n此外，在调试 Prompt 时我还发现一个问题：提示词写得好是一方面，模型的选择也同样至关重要。模型的输出效果固然依赖于提示词，但选择一个参数更大、版本更新的模型，往往能更大概率地改善最终效果。\n\n## 最后\n\n以上就是我的一些感悟，总结一下，在当前的 AI 项目实践中：\n\n1.  **提示词需要精心设计**：好的提示词需要不断打磨和完善。\n2.  **模型选择至关重要**：尽量选择参数量大、版本新的模型，这往往是提升效果最直接的方法。\n3.  **RAG 并非万能**：RAG 方案不一定是最优解，可以多考察类似 MCP Server 这样的工具调用（Tool Calling）方案，善用现有生态。\n",
    "createdAt": "2025-07-25T10:22:07Z",
    "updatedAt": "2025-07-25T10:22:07Z",
    "author": {
      "name": "bosens-China",
      "avatar": "https://avatars.githubusercontent.com/u/39508895?v=4"
    },
    "labels": [
      {
        "id": 8531648237,
        "name": "AI"
      }
    ],
    "reactions": 0,
    "comments": 0,
    "url": "https://github.com/bosens-China/blog/issues/127",
    "readingTime": 8,
    "excerpt": "分享一下我 5 月从事文旅 AI 助手的一些得与失，并探讨在对话场景下，怎样实现才更为合理。 首先补充一下项目背景：该项目涉及景区、美食、停车场、酒店、天气等信息。要求是：当用户提问时，系统能够基于数据库的内容进行润色后回答，且回答的模板可能是固定的，类似下面这种 不过，很快就遇到了第一个问题：如何...",
    "thumbnail": [
      "https://github.com/user-attachments/assets/f360a9e1-d493-44a3-88d7-4ff04c6d2258",
      "https://github.com/user-attachments/assets/3f35e157-a0af-4ed2-8d9e-f2026e3e0415"
    ],
    "column": null,
    "keywords": []
  },
  {
    "id": 126,
    "title": "漫谈 AI + 低代码前景",
    "content": "昨天看到一篇文章 [这个开源的「AI + 低代码」开发平台绝了，Gitee 上斩获 9.2K Star!](https://mp.weixin.qq.com/s/DBoMp7ymX5XS9zWz9LzCMw)，恰逢我也有相关的低代码和可视化方面的经验，这里就谈谈自己的看法，首先过下 VTJ.PRO 支持的功能列表。\n\n1. 代码还原，从大屏还原到本地代码\n2. 现有代码转化，转化为平台支持的代码（事件、参数等）\n3. 设计稿转化代码\n4. AI 流程检测\n5. 多平台\n\n> 这篇文章不是基于 VTJ.PRO 实现来探讨，只是我自己对 AI + 低代码的一些看法，算是这段时间 AI 学习的一个知识发散输出的一个过程。\n\n## 我的思考\n\n在我去年开发的可视化平台实践过程中，有一个比较大的矛盾点，就是对于很多定制化场景跟标准组件之间存在差异，需要有一个灵活的方式来弥补，当时的策略是通过开发自定义的组件来暴露能力。\n\n但是在工程实践中也发现存在一些问题：\n\n1. 配置起来可能需要了解，因为是在线使用，安装第三方包之类的使用需要熟悉；\n2. 对于大屏的渲染不是最优，因为存在一个网络加载的过程，初始化看起来有点奇怪；\n3. 代码体积可能没有办法优化，因为核心是通过 CDN 来加载包名，但是这个没办法来优化体积。\n\n但是在今年随着 AI 的不断发展完全有另外一套玩法，全平台基于 AI 来实现，一个简单的页面划分则为：\n\n1. 我的项目\n2. 项目页面（多页面，可以理解成一个多页面的路由）\n\n如果考虑商业化的，则还可以包含物料仓库等更多模块，当然这个不是这次讨论的重点。\n\n### 核心\n\n对于 AI 低代码平台我认为最核心的有两个模块：\n\n1. 画布核心能力\n2. 接入 AI 的具体落地方案\n\n#### 画布核心能力\n\n一个个来阐述，首先画布核心能力比较好理解，就是我们组件拖拽到画布区域除了预览，还应当有一系列相关的内置插件部分，还有支持功能的拓展部分，我们可以称为插件合适。\n\n例如：\n\n1. 组件的交互，例如如何对组件的属性来修改\n2. 页面层级的交互，怎么来跳转起来页面，获取当前页面的信息等\n3. 操作的撤销等，需要维护一个历史记录\n4. 支持插件的注册，例如我们需要维护的操作历史同步和历史记录回滚都可以通过插件能力来实现\n\n综上基于画布核心能力，我们可以得到一个认知，一个低代码平台比较重要的就是统一协议，暴露底层能力让拓展可以基于插件的形式来进行维护和迭代新功能。例如我们要讨论的方案 2 就是基于协议和插件来实现。\n\n> 协议之所以重要，是因为对于这种低代码的平台，必须对格式以及事件、交互等有统一、具体的要求，不然就会导致陷入泥潭状态漫天分。\n\n#### 接入 AI\n\n这一步比较庞大，需要思考的点也很多，在传统的 AI IDE 中，更多的时候我们通过对话的形式，Agent 根据对话内容就会创建相关的文件来对文件进行创建和修改，排查问题等。\n\n但是考虑在低代码这样的平台中，我认为从 0 到 1 可能不是完全可取的，因为首先我们的低代码肯定是给没有太多编程基础的人使用\n\n1. 不了解代码\n2. 重复生成多个文件，没有利用到平台架设的便利性，展开来说就是其实就是平台可能内置了很多大屏相关的生态组件库，理想情况下，AI 生成的时候直接复用，然后基于生成的组件进行拖拽布局，结合画布也可以做到很好的微调效果。\n\n> 之所以内置很多大屏相关的组件库，其实也是为了健壮性，以及充分利用平台的优势，如果只是单纯的一个壳子，虽然也很重要，但是会写很多的代码，从长久来看内置这部分会导致 AI 可以省去很多的工作量。\n\n在 AI 能力这块，从 23 年的对话和 AI IDE 的对话，到最新的各种 CODE CLI 的 AI 工具，可以发现我们更多跟 AI 的配合还是通过对话框的形式来去触发。\n\n有这么多的实践在这里，所以结合平台接入 AI 的最佳路径依然是通过对话框 + Agent 的形式来去使用。\n\n具体来看交互则是：\n\n1. 用户输入自己的需求\n2. AI（微调过的），结合当前的组件库和实践，给出需求拆解后的组件列表\n3. 通过协议插入到画布的组件物料区域\n4. 用户拖拽物料到画布区域\n5. 点击发布\n\n这个就是一个完整的交互流程，不过在真实的场景中也需要考虑很多信息\n\n1. 如果超出上下文怎么处理\n2. 对于组件的微调和修改怎么做\n3. 对于动态创建的组件我们怎么能实现性能最佳\n4. ...\n\n可以看到结合 AI 的赋能，我们依然有很多问题需要去解决和完善，这里就一一讨论一下。\n\n1. 模型的上下文随着对话的轮次增加大概率是会超出的，解决方案我认为有两个 1 个是选择模型的时候选择上下文比较大的，例如 Gemini，这个支持最高 200M 的 token，很多场景绝对用不完，但是假设模型用的是比较小的上下文，这里可以考虑使用记忆功能，这个是一个比较火热的 AI 研究方向，基于对信息的压缩，让 AI 记忆重要信息。\n\n2. 对于组件的微调，我认为依然需要有一个在线的 IDE 提供给用户，让用户修改的时候可以实时看到，此外还应当提供类似 Cursor 这样的直接在编辑器内对话的能力，可以直接对齐内容进行 AI 的修改\n\n> 这里有一个前提，就是我们在解析用户的对话的时候会根据意图创建多个组件，但是这个组件的划分是一个个大的组件来实现的，这样我们去修改和拖拽的时候更多的时候是拖拽一个模块\n\n3. 对于动态组件这个也是需要核心考虑的地方，因为最初最初的自定义组件是基于 iframe 来创建的，这个是导致性能降低的罪魁祸首，但是只考虑性能的最佳实践我认为有两个\n   - 基于云打包代码来实现，把自定义组件归纳成一个个文件，通过云在线打包工具把代码打包成相关的 js 文件，最后随着平台一起加载\n   - 基于联邦模块（Module Federation）来实现，虽然本质还是在线加载，但是不是基于 iframe 方案实现的表现也很好，例如 [模块联邦 - Rsbuild](https://rsbuild.rs/zh/guide/advanced/module-federation)[模块联邦 - Rsbuild](https://rsbuild.rs/zh/guide/advanced/module-federation)\n\n## 其他\n\n### 设计稿\n\n这块技术站在这个时间节点来看已经比较成熟了，各家的平台基本都支持 MCP 获取设计稿的信息了，只需要配置填写下即可。\n\n所以如果要做，我们的平台肯定要一个地方暴露和设置的地方，当然如果野心更大一些，我们设置可以把设计平台接进来， 同样基于 AI 生成设计稿，直接无缝插入进来。这也是一个广阔的前景。\n\n### 代码还原本地\n\n这个功能也非常有代表性，可以显著提升定制化的能力，如果我们的核心架构能力实现足够优秀，这个问题不是一个很大的问题，具体来讲解：\n\n1. 我们的平台也就是画布预览的基层可以发布到 npm 上，后续我们还原的话，也只需要给一个初始化的工程结构，里面安装了我们平台的依赖包，我们默认帮他写好\n2. 通过数据库我们了解画布的相关设置，然后对初始化工程进行修改\n3. 基于 AI 组件的拖拽，我们直接可以获取到源代码，还原成类似的 vue 之类源码\n\n组装完成后，直接生成 zip 文件给用户，完成整个平台的流程。\n\n## 多平台\n\n这块其实我觉得还是借助 AI 的能力，我们的画布本身支持相关的缩放即可，预设好相关的响应式能力。\n\n后续生成 AI 的时候，无论是通过微调还是提示词，我们让 AI 了解怎么来适配响应式，结合我们的平台就可以做到。\n\n当然对于小程序这样的平台可能有点麻烦，因为一方面语法对比传统的 web 可能不支持，另外一方面则是小程序的生态以及文档不够多，AI 可能需要专门对这方面来进行训练。\n\n但是一定是可以的，因为我的 nextjs 搭建的博客，就是基本是 AI 开发，支持 pc、平板和手机。\n\n> [小 🐑 的博客 - 个人写博客的地方](https://bosens-china.github.io/blog/page/1/)\n\n## 最后\n\n还有很多可以讨论的点，例如关于接口的交互，物料区域的搭建等，甚至延伸来看是不是版本的控制也很重要，以及多人的协作开发？\n",
    "createdAt": "2025-07-25T09:07:04Z",
    "updatedAt": "2025-07-25T09:07:04Z",
    "author": {
      "name": "bosens-China",
      "avatar": "https://avatars.githubusercontent.com/u/39508895?v=4"
    },
    "labels": [
      {
        "id": 8531648237,
        "name": "AI"
      }
    ],
    "reactions": 0,
    "comments": 0,
    "url": "https://github.com/bosens-China/blog/issues/126",
    "readingTime": 13,
    "excerpt": "昨天看到一篇文章 这个开源的「AI + 低代码」开发平台绝了，Gitee 上斩获 9.2K Star!，恰逢我也有相关的低代码和可视化方面的经验，这里就谈谈自己的看法，首先过下 VTJ.PRO 支持的功能列表。 代码还原，从大屏还原到本地代码 现有代码转化，转化为平台支持的代码（事件、参数等） 设计...",
    "thumbnail": [],
    "column": null,
    "keywords": []
  }
]